name: 'Degas Firmware Dumper'

on:
  schedule:
    # Run daily at 00:00 UTC to process backlog
    - cron: '0 0 * * *'
  
  push:
    branches:
      - main
    paths:
      - 'firmware_updates/*.json'
    tags-ignore:
      - '**'  # Prevent re-runs when tags are created
  
  workflow_dispatch:
    inputs:
      region:
        description: 'Region to process (leave empty for all)'
        required: false
        type: choice
        options:
          - ''
          - global
          - eea
          - ru
          - id
          - tw
          - tr
          - global_dc

# Prevent multiple runs of this workflow
concurrency:
  group: firmware-dumper-${{ github.ref }}
  cancel-in-progress: false

jobs:
  update_manifests:
    name: 'Update Firmware Manifests'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      
      - name: Check for Latest Firmware Updates
        run: |
          echo "ðŸ” Checking Mi Community API for firmware updates..."
          python3 .github/scripts/check_firmware_mi_community.py
      
      - name: Commit Manifest Changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          if git diff --quiet firmware_updates/; then
            echo "â„¹ï¸  No manifest changes"
          else
            git add firmware_updates/
            git commit -m "ðŸ“¦ Update firmware manifests [skip ci]"
            git pull --rebase
            git push
            echo "âœ… Manifests updated"
          fi

  process_firmware_files:
    name: 'Process Firmware (${{ matrix.region }})'
    needs: update_manifests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      fail-fast: false  # Continue other regions if one fails
      max-parallel: 7   # Process all regions in parallel
      matrix:
        region: [global, eea, ru, id, tw, tr, global_dc]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            /var/cache/apt
            /var/lib/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/firmware_updater.yml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y aria2 tree pigz python3

      - name: Read Manifest and Find Next Version
        id: firmware_info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REGION: ${{ matrix.region }}
        run: |
          MANIFEST_PATH="firmware_updates/${REGION}.json"
          
          # Check if manifest exists
          if [ ! -f "$MANIFEST_PATH" ]; then
            echo "No manifest for region ${REGION}. Skipping."
            echo "DATA_FOUND=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Parse manifest and find first unprocessed version
          python3 << 'PYEOF'
import json
import os
import sys
from subprocess import run

manifest_path = f"firmware_updates/{os.environ['REGION']}.json"

# Load manifest
try:
    with open(manifest_path, 'r') as f:
        manifest = json.load(f)
except Exception as e:
    print(f"Error loading manifest: {e}")
    sys.exit(0)

versions = manifest.get('versions', [])
if not versions:
    print("No versions in manifest")
    sys.exit(0)

# Get existing releases
result = run(['gh', 'release', 'list', '--limit', '1000', '--json', 'tagName'],
             capture_output=True, text=True)

existing_tags = set()
if result.returncode == 0 and result.stdout.strip():
    try:
        releases = json.loads(result.stdout)
        existing_tags = {r['tagName'] for r in releases}
        print(f"Found {len(existing_tags)} existing releases for comparison")
    except Exception as e:
        print(f"Warning: Could not parse releases: {e}")

# Find oldest unprocessed version by date
region = os.environ['REGION']
unprocessed = []
for version_info in versions:
    tag = f"v{version_info['version']}-{region}"
    if tag not in existing_tags:
        unprocessed.append(version_info)
    else:
        print(f"  â­ï¸  Skipping {version_info['version']} (already released as {tag})")

if not unprocessed:
    print(f"âœ… All versions already released for {region}")
    sys.exit(0)

# Sort unprocessed by date (oldest first)
try:
    unprocessed.sort(key=lambda x: x.get('date', '9999-99-99'))
except Exception as e:
    print(f"âš ï¸  Warning: Could not sort by date: {e}")
    print("Processing first unprocessed version found")

# Get oldest unprocessed (first after sorting by date)
next_version = unprocessed[0]
print(f"ðŸ“¦ Found {len(unprocessed)} unprocessed version(s)")
print(f"ðŸŽ¯ Will process oldest: {next_version['version']} ({next_version.get('date', 'unknown date')})")

# Select fastest URL by testing all mirrors
urls = next_version['urls']
fastest_url = urls[0]

if len(urls) > 1:
    print("Testing mirror speeds (10MB sample)...")
    mirror_speeds = []
    
    for url in urls:
        mirror_name = url.split('/')[2]  # Extract domain
        result = run(['curl', '-L', '--connect-timeout', '5', '--max-time', '10',
                     '--range', '0-10485759', '-s', '-o', '/dev/null', 
                     '-w', '%{speed_download}', url],
                    capture_output=True, text=True)
        try:
            speed = float(result.stdout.strip())
            speed_mbps = (speed / 1024 / 1024)
            mirror_speeds.append((url, speed_mbps, mirror_name))
            print(f"  {mirror_name}: {speed_mbps:.2f} MB/s")
        except:
            print(f"  {mirror_name}: Failed")
            mirror_speeds.append((url, 0, mirror_name))
    
    # Sort by speed (fastest first)
    mirror_speeds.sort(key=lambda x: x[1], reverse=True)
    
    if mirror_speeds[0][1] > 0:
        fastest_url = mirror_speeds[0][0]
        print(f"âœ… Selected: {mirror_speeds[0][2]} ({mirror_speeds[0][1]:.2f} MB/s)")
    else:
        print("âš ï¸  All mirrors failed speed test, using first URL")
        fastest_url = urls[0]

filename = fastest_url.split('/')[-1]

# Output to GitHub Actions
with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
    f.write(f"VERSION={next_version['version']}\n")
    f.write(f"FILENAME={filename}\n")
    f.write(f"DOWNLOAD_URL={fastest_url}\n")
    f.write(f"HYPEROS_VERSION={next_version.get('hyperos_version', 'Unknown')}\n")
    f.write(f"ANDROID_VERSION={next_version.get('android_version', 'Unknown')}\n")
    f.write(f"RELEASE_DATE={next_version.get('date', 'Unknown')}\n")
    f.write(f"MD5_HASH={next_version.get('md5', 'Unknown')}\n")
    f.write(f"CHANGELOG={next_version.get('changelog', 'Official firmware release')}\n")
    f.write(f"DATA_FOUND=true\n")

print(f"âœ… Will process: {next_version['version']}")
PYEOF

      - name: Check if Release Already Exists
        if: steps.firmware_info.outputs.DATA_FOUND == 'true'
        id: check_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="v${{ steps.firmware_info.outputs.VERSION }}-${{ matrix.region }}"
          echo "ðŸ” Double-checking tag: ${TAG}"
          if gh release view "$TAG" --json name >/dev/null 2>&1; then
            echo "âš ï¸  Release ${TAG} already exists (race condition detected). Stopping."
            echo "IS_NEW=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Release ${TAG} is new. Proceeding with download."
            echo "IS_NEW=true" >> $GITHUB_OUTPUT
          fi

      - name: Free up disk space on runner
        if: steps.check_release.outputs.IS_NEW == 'true'
        run: |
          echo "Freeing up disk space..."
          df -h
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache/CodeQL \
                      /opt/hostedtoolcache/go /opt/hostedtoolcache/Python /opt/hostedtoolcache/Ruby \
                      /opt/hostedtoolcache/Java "$AGENT_TOOLSDIRECTORY" 2>/dev/null || true
          docker system prune -af 2>/dev/null || true
          sudo apt-get clean
          echo "Disk space after cleanup:"
          df -h

      - name: Download and Extract Firmware
        if: steps.check_release.outputs.IS_NEW == 'true'
        run: |
          FILENAME="${{ steps.firmware_info.outputs.FILENAME }}"
          
          echo "Downloading ${FILENAME} with aria2..."
          aria2c -x 16 -s 16 -k 1M -o "${FILENAME}" "${{ steps.firmware_info.outputs.DOWNLOAD_URL }}"
          
          echo "Calculating MD5 hash..."
          MD5_HASH=$(md5sum "${FILENAME}" | awk '{print $1}')
          echo "MD5=${MD5_HASH}" >> $GITHUB_OUTPUT
          echo "MD5: ${MD5_HASH}"
          
          echo "Extracting .tgz fastboot package..."
          mkdir -p extracted_firmware
          tar -I pigz -xvf "${FILENAME}" -C extracted_firmware
          
          echo "Handling large files..."
          find extracted_firmware -type f -size +2000M | while read -r file; do
            echo "Splitting large file: $file"
            split -b 2000M "$file" "$file.part-"
            rm -f "$file"
          done
          
          rm -f "${FILENAME}"
        id: download

      - name: Update Manifest with MD5
        if: steps.check_release.outputs.IS_NEW == 'true'
        env:
          REGION: ${{ matrix.region }}
          VERSION: ${{ steps.firmware_info.outputs.VERSION }}
          MD5: ${{ steps.download.outputs.MD5 }}
        run: |
          python3 << 'PYEOF'
import json
import os

region = os.environ['REGION']
version = os.environ['VERSION']
md5 = os.environ['MD5']

manifest_path = f"firmware_updates/{region}.json"
with open(manifest_path, 'r') as f:
    manifest = json.load(f)

# Find and update version with MD5
for v in manifest['versions']:
    if v['version'] == version:
        v['md5'] = md5
        break

# Save updated manifest
with open(manifest_path, 'w') as f:
    json.dump(manifest, f, indent=2)

print(f"âœ… Updated manifest with MD5: {md5}")
PYEOF

      - name: Create GitHub Release and Upload Files
        if: steps.check_release.outputs.IS_NEW == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          VERSION="${{ steps.firmware_info.outputs.VERSION }}"
          REGION_UPPER=$(echo "${{ matrix.region }}" | tr 'a-z' 'A-Z')
          TAG="v${VERSION}-${{ matrix.region }}"
          
          tree -F extracted_firmware > extracted_firmware/file_structure.txt
          
          TOTAL_SIZE=$(du -sh extracted_firmware | awk '{print $1}')
          FILE_COUNT=$(find extracted_firmware -type f | wc -l)
          DUMP_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          RELEASE_NOTES=$(cat <<EOF
          ## ðŸ“¦ Firmware Information
          
          - **Version:** ${VERSION}
          - **Region:** ${REGION_UPPER}
          - **HyperOS Version:** ${{ steps.firmware_info.outputs.HYPEROS_VERSION }}
          - **Android Version:** ${{ steps.firmware_info.outputs.ANDROID_VERSION }}
          - **Release Date:** ${{ steps.firmware_info.outputs.RELEASE_DATE }}
          - **MD5 Hash:** \`${{ steps.download.outputs.MD5 }}\`
          
          ## ðŸ“Š Package Details
          
          - **Total Size:** ${TOTAL_SIZE}
          - **File Count:** ${FILE_COUNT}
          - **Dump Date:** ${DUMP_DATE}
          - **Codename:** degas (Xiaomi 14T)
          
          ## ðŸ”— Source
          
          Downloaded from: ${{ steps.firmware_info.outputs.DOWNLOAD_URL }}
          
          ---
          
          ðŸ“„ A complete file list and directory structure is available in the \`file_structure.txt\` asset attached below.
          EOF
          )

          echo "Creating release with tag: ${TAG}"
          gh release create "$TAG" \
            --title "ðŸš€ ${VERSION} [${REGION_UPPER}]" \
            --notes "$RELEASE_NOTES" \
            $(find extracted_firmware -type f)

      - name: Commit Updated Manifest
        if: steps.check_release.outputs.IS_NEW == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Pull latest changes first to avoid conflicts with parallel jobs
          git pull --rebase origin main || true
          
          git add firmware_updates/${{ matrix.region }}.json
          if git diff --staged --quiet; then
            echo "â„¹ï¸  No changes to commit"
            exit 0
          fi
          
          git commit -m "Update ${{ matrix.region }} manifest with MD5 for ${{ steps.firmware_info.outputs.VERSION }} [skip ci]"
          
          # Retry push up to 3 times in case of parallel push conflicts
          for i in {1..3}; do
            if git push; then
              echo "âœ… Manifest pushed successfully"
              break
            else
              echo "âš ï¸  Push failed, attempt $i/3"
              if [ $i -lt 3 ]; then
                sleep $((5 + RANDOM % 10))  # Random delay 5-15 seconds
                git pull --rebase origin main
              else
                echo "âŒ Failed to push after 3 attempts"
                exit 1
              fi
            fi
          done

  update_readme:
    needs: process_firmware_files
    runs-on: ubuntu-latest
    if: success() || failure()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Update Firmware Index in README
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 .github/scripts/update_firmware_index.py

      - name: Commit and Push README Changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are changes
          if git diff --quiet README.md; then
            echo "â„¹ï¸  No changes to README.md"
            exit 0
          fi
          
          # Pull latest changes before pushing
          git pull --rebase origin main || true
          
          # Commit and push
          git add README.md
          git commit -m "ðŸ“ Update firmware index [skip ci]"
          git push origin main
          echo "âœ… README.md updated and pushed"
